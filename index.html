<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>実行計画とオプティマイザ入門：内部構造からパフォーマンスチューニングまで</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&family=Fira+Code:wght@500&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/v10-plus.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/sql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/pgsql.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/json.min.js"></script>
    <script>hljs.highlightAll();</script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --accent-color: #e74c3c;
            --code-pg-foreground: #24292e;
            --code-pg-background: #ebebeb;
            --code-ln-foreground: #a8a8a8;
            --code-out-foreground: #ebebeb;
            --code-out-background: #012456;
            --main-foreground: #24292e;
            --bg-color: #f4f6f7;
            --deep-dive-bg: #ebf5fb;
            --deep-dive-border: #3498db;
            --math-bg: #fff;
            --math-border: #f1c40f;
        }

        body {
            font-family: "M PLUS Rounded 1c", -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--main-foreground);
            line-height: 1.8;
            margin: 0;
            padding: 20px;
        }

        header {
            background: linear-gradient(135deg, #1a252f, #34495e);
            color: white;
            padding: 60px 20px;
            text-align: center;
            border-radius: 8px;
            margin-bottom: 50px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }

        h1 {
            margin: 0;
            font-size: 3em;
            font-weight: 800;
            letter-spacing: -1px;
        }

        h2 {
            border-bottom: 4px solid var(--accent-color);
            padding-bottom: 10px;
            margin-top: 60px;
            font-size: 2em;
            color: var(--primary-color);
        }

        h3 {
            border-left: 6px solid #34495e;
            padding-left: 15px;
            margin-top: 40px;
            font-size: 1.5em;
        }

        /* Revised code block styling based on user feedback */
        pre {
            background-color: var(--code-pg-background);
            color: var(--code-pg-foreground);
            padding: 20px;
            border-radius: 10px;
            overflow-x: auto;
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
            margin-block-start: 0.7em;
            margin-block-end: 0.7em;
            position: relative;
            /* Context for absolute positioning if needed */
        }

        /* Data Caption Styling */
        pre[data-caption] {
            padding-top: 0;
            /* Caption takes top space */
            padding-left: 0;
            padding-right: 0;
            overflow: hidden;
            /* Ensure caption background doesn't overflow */
        }

        pre[data-caption]::before {
            content: attr(data-caption);
            display: block;
            background: var(--code-pg-foreground);
            color: var(--code-pg-background);
            padding: 5px 20px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace;
            font-size: 0.85em;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            margin-bottom: 10px;
        }

        pre[data-caption] code {
            display: block;
            padding: 0 20px 20px 20px;
            overflow-x: auto;
        }

        /* Expert Sections */
        .deep-dive {
            background-color: var(--deep-dive-bg);
            border-left: 6px solid var(--deep-dive-border);
            padding: 25px;
            margin: 40px 0;
            border-radius: 0 8px 8px 0;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        .deep-dive h4 {
            color: var(--deep-dive-border);
            margin: 0 0 15px 0;
            font-size: 1.2em;
            display: flex;
            align-items: center;
        }

        .deep-dive h4::before {
            content: "🎓 INTERNALS: ";
            font-weight: 900;
            margin-right: 10px;
        }

        .math-box {
            background-color: var(--math-bg);
            border: 2px solid var(--math-border);
            padding: 20px;
            margin: 30px 0;
            border-radius: 8px;
            position: relative;
        }

        .math-box::after {
            content: "Math & Logic";
            position: absolute;
            top: -12px;
            right: 20px;
            background: var(--math-border);
            color: #000;
            padding: 2px 10px;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 4px;
        }

        .math-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.2em;
            text-align: center;
            margin: 15px 0;
            color: #333;
        }

        /* Drill Layout - Vertical now */
        .drill-container {
            display: flex;
            flex-direction: column;
            gap: 30px;
            margin-top: 30px;
        }

        .drill-card {
            background: white;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            border-left: 5px solid #bdc3c7;
            transition: all 0.3s ease;
        }

        .drill-card:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .drill-card.type-sql {
            border-left-color: #27ae60;
        }

        .drill-card.type-theory {
            border-left-color: #2980b9;
        }

        .drill-card.type-hard {
            border-left-color: #e74c3c;
        }

        .drill-q {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        details[open] summary {
            margin-bottom: 15px;
            border-bottom: 1px dashed #ccc;
        }

        summary {
            cursor: pointer;
            color: #7f8c8d;
            font-weight: bold;
            outline: none;
            padding: 5px 0;
        }

        .answer {
            font-size: 0.95em;
            color: #444;
            background: #f9f9f9;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #27ae60;
            line-height: 1.6;
        }

        .tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            color: white;
            margin-right: 10px;
            vertical-align: middle;
            font-weight: bold;
        }

        .tag-calc {
            background: #8e44ad;
        }

        .tag-algo {
            background: #2980b9;
        }

        .tag-sql {
            background: #27ae60;
        }

        .tag-deep {
            background: #e67e22;
        }

        .drill-code {
            display: block;
            border-left: 5px solid #3498db;
            margin: 15px 0;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow-x: auto;
            /* Background handled by pre */
        }

        .drill-code[data-caption]::before {
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
        }

        pre code.hljs {
            font-family: 'Fira Code', monospace;
            font-size: 0.95em;
            padding: 0;
            /* pre has padding already */
            background: transparent;
            /* Let pre handle background */
            border-radius: 4px;
            line-height: 1.5;
        }

        .star-rating {
            color: #f1c40f;
            font-size: 0.9em;
            margin-left: 10px;
            letter-spacing: 2px;
        }

        table.cost-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }

        table.cost-table th,
        table.cost-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }

        table.cost-table th {
            background-color: #f2f2f2;
            color: #333;
        }
    </style>
</head>

<body>

    <header>
        <h1>実行計画とオプティマイザ入門</h1>
        <div style="margin-top: 20px; font-size: 0.9em; opacity: 0.9;">
            EXPLAIN、Seq Scan vs Index Scan、コストモデル<br>
            「データベースの気持ち（実行計画）」を読み解き、適切なチューニングを行うための実践講義
        </div>
    </header>

    <main style="max-width: 1000px; margin: 0 auto;">

        <section id="intro">
            <h2>0. 序論：なぜそのSQLは遅いのか？</h2>
            <p>SQLは「何が欲しいか (What)」を記述する言語であり、「どうやって取るか (How)」を指定する言語ではありません。<br>
                その「How」を決定しているのが、データベースの頭脳である<strong>オプティマイザ (Optimizer)</strong> です。</p>
            <p>本講義の目的は、オプティマイザが生成する<strong>実行計画 (Execution Plan)</strong> を <code>EXPLAIN</code>
                コマンドを使って読み解けるようになることです。<br>
                「なぜインデックスを使わないのか？」「なぜこの結合順序なのか？」その理由をコストモデルに基づいて理解し、論理的なパフォーマンスチューニングを行う能力を養います。</p>
        </section>

        <section id="setup">
            <h2>0.5. 環境構築と事前準備 (Prerequisites & Setup)</h2>
            <div class="deep-dive" style="border-left-color: #e74c3c;">
                <h4 style="color: #e74c3c;">前提環境</h4>
                <p>本記事のすべての検証データおよび実行計画は、以下の環境で取得・検証されています。<br>
                    <strong>PostgreSQL 17.0 (Docker Container: postgres:17-alpine)</strong>
                </p>
                <p>以下のSQLを実行して、検証用テーブル <code>users_expert</code> (100万件) を作成してください。</p>
            </div>

            <pre data-caption="検証環境セットアップ用SQL (約10秒で完了)"><code class="language-sql">-- 1. テーブル作成
CREATE TABLE users_expert (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255),
    category_id INT,
    score INT,
    pref_code INT,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 2. データ生成 (100万行: generate_series)
INSERT INTO users_expert (email, category_id, score, pref_code, created_at)
SELECT 
    'user_' || i || '@example.com',
    floor(random() * 10 + 1)::int,   -- category: 1-10
    floor(random() * 100 + 1)::int,  -- score: 1-100
    floor(random() * 47 + 1)::int,   -- pref: 1-47
    NOW() - (random() * interval '365 days')
FROM generate_series(1, 1000000) AS s(i);

-- 3. 統計情報の更新 (重要)
ANALYZE users_expert;</code></pre>
        </section>

        <section id="internals">
            <h2>1. オプティマイザが管理する物理構造 (Internals)</h2>

            <div class="deep-dive">
                <h4>全ては 8KB のページコストから始まる</h4>
                <p>オプティマイザのコスト計算の基礎単位は「ページ（ブロック）」です。デフォルトサイズは <strong>8KB (8192 bytes)</strong> です。<br>
                    100万件のデータは、連続した1つのファイルではなく、数千〜数万個の8KBの箱に分割されてディスクに保存されています。</p>
                <ul>
                    <li><strong>Heap (Table)</strong>: 実際の行データ (Tuple) が詰め込まれている場所。整理整頓されておらず、挿入順に置かれる（追記型）。</li>
                    <li><strong>Index (B-tree)</strong>: 特定のカラムの値と、その行が「どのページのどこにあるか」を示す住所 (TID: Tuple Identifier)
                        を持った、整理された木構造。</li>
                </ul>
            </div>

            <p>今回の実験で作った <code>users_expert</code> テーブル (100万件) の物理サイズを確認してみましょう。</p>
            <pre><code class="language-sql">SELECT relpages, reltuples FROM pg_class WHERE relname = 'users_expert';
-- 結果: relpages = 17906, reltuples = 1000000</code></pre>
            <p>つまり、100万件のデータは <strong>17,906個</strong> の8KBページに格納されているということです。<br>
                全データを読む (Seq Scan) ということは、この17,906ページ全てをディスクからメモリに読み込むことを意味します。</p>
        </section>

        <section id="cost-model">
            <h2>2. オプティマイザの頭脳：コストモデル (Cost Model)</h2>
            <p><code>EXPLAIN</code> で表示される <code>cost=27906.00</code> のような謎の数字。これはオプティマイザが以下のパラメータを使って計算した「推定コスト」です。</p>


            <pre data-caption="実行結果: コストパラメータの確認"><code class="language-pgsql">testdb=# SHOW seq_page_cost;
 seq_page_cost 
---------------
 1
(1 row)

testdb=# SHOW random_page_cost;
 random_page_cost 
------------------
 4
(1 row)

testdb=# SHOW cpu_tuple_cost;
 cpu_tuple_cost 
----------------
 0.01
(1 row)</code></pre>

            <div class="math-box">
                <h4>Seq Scan コストの証明</h4>
                <div class="math-formula">
                    Seq Scan Cost = (Disk Pages × seq_page_cost) + (Rows × cpu_tuple_cost)
                </div>
                <p>今回の <code>users_expert</code> テーブルの物理統計情報は以下の通りです（実測値）。</p>
                <pre><code>          relname           | Total Pages (8KB blocks) | Total Rows | Total Size 
----------------------------+--------------------------+------------+------------
 users_expert               |                    17906 |    1000000 | 140 MB</code></pre>

                <p>Calculation:<br>
                    <code>(17906 * 1.0) + (1000000 * 0.01) = 17906 + 10000 = <strong>27,906.00</strong></code>
                </p>
                <p>実際の実行計画を見てみましょう。コストの値がこの計算と完全に一致していることが確認できます。</p>


                <pre data-caption="実行結果: Seq Scan のコスト"><code class="language-json">EXPLAIN (FORMAT JSON, ANALYZE) SELECT * FROM users_expert WHERE score = 50;
----------------------------------------------------------------------------------
 [
   {
     "Plan": {
       "Node Type": "Seq Scan",
       "Relation Name": "users_expert",
       "Startup Cost": 0.00,
       "Total Cost": 27906.00,    <-- 計算通りの値！
       "Plan Rows": 10110,
       "Plan Width": 68,
       "Actual Startup Time": 0.055,
       "Actual Total Time": 115.892,
       "Actual Rows": 9986,
       "Actual Loops": 1,
       "Filter": "(score = 50)",
       "Rows Removed by Filter": 990014
     },
     "Planning Time": 0.283,
     "Execution Time": 116.452
   }
 ]</code></pre>
            </div>
        </section>

        <section id="experiments">
            <h2>3. 実行計画の解析とケーススタディ</h2>

            <h3>ケーススタディ1: Index Scan が選ばれた理由</h3>
            <p>インデックスを作成後、同じクエリの実行計画がどう変化するか確認します。</p>

            <pre><code class="language-sql">CREATE INDEX idx_score_expert ON users_expert(score);</code></pre>

            <pre data-caption="実行結果: Index Scan"><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE score = 50;

Bitmap Heap Scan on users_expert  (cost=116.78..3630.90 rows=10033 width=68)
                                  (actual time=2.169..14.542 rows=9986 loops=1)
  Recheck Cond: (score = 50)
  Heap Blocks: exact=5724
  ->  Bitmap Index Scan on idx_score_expert  (cost=0.00..114.27 rows=10033 width=0)
                                            (actual time=1.353..1.353 rows=9986 loops=1)
        Index Cond: (score = 50)
Planning Time: 0.177 ms
Execution Time: 15.013 ms</code></pre>
            <p><strong>考察:</strong></p>
            <ul>
                <li><strong>Seq Scan (116ms) → Index Scan (15ms)</strong>: 約8倍の高速化です。</li>
                <li><strong>Bitmap Heap Scan</strong>: 今回はヒット件数が約1万件あるため、ランダムアクセスを少しでも減らすためにBitmap Scanが選ばれました。</li>
                <li><strong>Heap Blocks</strong>:
                    B-treeから得たTID(住所)を使って、5724個のヒープブロックを読みに行っていることがわかります。これがコストの大半を占めています。<br>
                    オプティマイザは「17,906ページ全部読む(Seq Scan)」よりも「インデックス + 5724ページ読む」方が安いと判断したのです。</li>
            </ul>

            <h3>ケーススタディ2: Index Only Scan と Visibility Map</h3>
            <p>次に、<code>INCLUDE</code> オプション付きのインデックス（カバリングインデックス）を使用した結果です。</p>

            <pre><code class="language-sql">CREATE INDEX idx_score_include ON users_expert(score) INCLUDE (id);</code></pre>

            <pre data-caption="実行結果: Index Only Scan"><code class="language-pgsql">EXPLAIN ANALYZE SELECT id, score FROM users_expert WHERE score = 50;

Index Only Scan using idx_score_include on users_expert  (cost=0.42..317.92 rows=10033 width=8)
                                                        (actual time=0.046..2.396 rows=9986 loops=1)
  Index Cond: (score = 50)
  Heap Fetches: 0
Planning Time: 0.160 ms
Execution Time: 3.125 ms</code></pre>
            <div class="deep-dive">
                <h4>テーブルを見に行かない究極の最適化</h4>
                <p><strong>Execution Time: 3.125 ms</strong>。通常の Index Scan (15ms) よりもさらに高速です。<br>
                    注目すべきは <strong><code>Heap Fetches: 0</code></strong>
                    という行です。これは「ヒープ（テーブル本体）へのアクセスが0回だった」ことを証明しています。<br>
                    必要な <code>id</code> と <code>score</code> が全てインデックス上にあり、かつ Visibility Map によって全行が有効であると保証されていたためです。
                </p>
            </div>
            <h3>ケーススタディ3: 複合インデックスと最左プレフィックス</h3>
            <p><code>(category_id, score)</code> の複合インデックスに対する2つのクエリ比較です。オプティマイザがインデックスを使える条件を確認します。</p>

            <pre><code class="language-sql">CREATE INDEX idx_category_expert ON users_expert(category_id, score);</code></pre>

            <h4>ケースA: 左側のカラム (Category) を指定した場合</h4>
            <pre><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE category_id = 50;

Bitmap Heap Scan on users_expert  (cost=114.77..3570.62 rows=9898 width=68)
                                  (actual time=1.868..14.306 rows=9909 loops=1)
  Recheck Cond: (category_id = 50)
  ->  Bitmap Index Scan on idx_category_expert  (cost=0.00..112.30 rows=9898 width=0)
                                               (actual time=1.272..1.272 rows=9909 loops=1)</code></pre>
            <p>問題なくインデックスが使われています。</p>

            <h4>ケースB: 右側のカラム (Score) のみを指定した場合</h4>
            <pre><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE score = 50;
-- (idx_score_expert を削除した状態で実行)

Seq Scan on users_expert  (cost=0.00..27906.00 rows=10110 width=68)
                          (actual time=0.063..118.590 rows=9986 loops=1)
  Filter: (score = 50)</code></pre>
            <p><strong>インデックスが使われていません（Seq Scan）。</strong><br>
                <code>(category_id, score)</code> インデックスは、category_id でソートされた状態であるため、いきなり score
                を探すことは辞書を「後ろの文字」で引くようなものであり、物理的に不可能なのです。<br>
                この制約のために、オプティマイザは Seq Scan を選択せざるを得ませんでした。
            </p>
        </section>

        <section id="more-experiments">
            <h3>ケーススタディ4: 範囲検索とソートの最適化</h3>
            <p>B-tree は順序を持っているため、オプティマイザは「ソート処理(Sort Node)を省略できるか」を常にチェックしています。</p>


            <pre data-caption="実行結果: Range Scan"><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE score BETWEEN 10 AND 20;

Bitmap Heap Scan on users_expert ...
  ->  Bitmap Index Scan on idx_score_expert
        Index Cond: ((score >= 10) AND (score <= 20))</code></pre>

            <p>さらに強力なのが <strong>ソート回避</strong> です。<code>ORDER BY</code>
                は通常、重いソート処理（メモリ不足時はディスクソート）が発生しますが、インデックスを使えば「既に並んでいるものを読むだけ」になります。</p>


            <pre data-caption="実行結果: Sort Avoidance (Limit)"><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert ORDER BY score LIMIT 10;

Limit  (cost=0.42..1.17 rows=10 width=68) (actual time=0.046..0.063 rows=10 loops=1)
  ->  Index Scan using idx_score_expert on users_expert  (cost=0.42..30255.42 rows=1000000 width=68)
                                                        (actual time=0.045..0.061 rows=10 loops=1)
Planning Time: 0.089 ms
Execution Time: 0.078 ms</code></pre>
            <p><strong>Execution Time: 0.078 ms</strong>。<br>
                <code>Sort</code> ノードが存在しません。100万件あっても、B-treeの端から10個拾うだけなので、一瞬で終わります。
            </p>

            <h3>ケーススタディ5: アンチパターン (オプティマイザの敗北)</h3>
            <div class="deep-dive">
                <h4>オプティマイザがインデックスを捨てる時</h4>
                <p>「インデックスを作ったのに使われない」という相談が後を絶ちません。オプティマイザが「使わない」と判断した理由を読み解きます。</p>
            </div>

            <h4>ケース1: 演算子の使用 (Calculation)</h4>

            <pre data-caption="実行結果: WHERE score + 10 = 50"><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE score + 10 = 50;

Seq Scan on users_expert  (cost=0.00..30406.00 rows=5000 width=68)
                          (actual time=0.061..135.532 rows=9964 loops=1)
  Filter: ((score + 10) = 50)</code></pre>
            <p><code>score</code> カラムではなく <code>score + 10</code> という計算結果に対して条件指定しているため、インデックスは使えません。<br>
                オプティマイザは「計算後の値」を知るすべがないため、全件計算して確かめるしかない（Seq Scan）と判断します。</p>

            <h4>ケース2: カーディナリティ (Cardinality) の罠</h4>
            <p><code>pref_code</code> (1〜47) に対して、<code>pref_code > 0</code> （つまり全件ヒット）を実行した場合。</p>

            <pre data-caption="実行結果: High Hit Rate"><code class="language-pgsql">EXPLAIN ANALYZE SELECT * FROM users_expert WHERE pref_code > 0;

Seq Scan on users_expert ...
  Filter: (pref_code > 0)</code></pre>
            <p>インデックスを使うと「インデックスを読む + ランダムアクセスする」という2度手間になります。全件取得するなら、端から順に読む Seq Scan の方が圧倒的に速いのです。</p>
        </section>

        <section id="drills">
            <h2>4. パフォーマンスチューニング演習 (全20問)</h2>
            <p>実行計画を最適化し、クエリを高速化するための演習問題です。「オプティマイザに最適なパスを選ばせるにはどうすればよいか」という視点で解いてください。</p>

            <h3>第1部: 基礎理論 (Theory & Math)</h3>
            <div class="drill-container">

                <div class="drill-card type-theory">
                    <div class="drill-q">
                        <span>Q1. B-tree計算量と高さ</span>
                        <span class="star-rating">★☆☆☆☆</span>
                    </div>
                    <div>
                        <p>データ件数 <i>N</i> = 1,000,000
                            のテーブルで <code>WHERE id = 1</code> を実行しました。オプティマイザはなぜ Seq Scan ではなく Index Scan
                            を選択したのですか？コスト（I/O）の観点から説明してください。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 圧倒的にページアクセス数が少ないから (3ページ vs 17906ページ)。</strong><br>
                            Seq
                            Scanでは全ページ(17906)を読む必要がありますが、B-treeを使えば、ルート→ブランチ→リーフとわずか2〜3ページ読むだけで該当行（およびそのTID）に到達できます。オプティマイザはこの物理的なI/O差をコスト計算に反映しています。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-theory">
                    <div class="drill-q">
                        <span>Q2. コストモデルの計算</span>
                        <span class="star-rating">★★☆☆☆</span>
                    </div>
                    <div>
                        <p>あるクエリの実行計画で、<code>Disk Pages = 100</code>, <code>Rows = 500</code> でした。<br>
                            <code>seq_page_cost = 1.0</code>, <code>cpu_tuple_cost = 0.01</code> の環境において、Seq Scan
                            の推定コスト値を計算してください。
                        </p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 105.00</strong><br>
                            計算式: <code>(Disk Pages × seq_page_cost) + (Rows × cpu_tuple_cost)</code><br>
                            = (100 × 1.0) + (500 × 0.01)<br>
                            = 100 + 5.0 = 105.0
                        </div>
                    </details>
                </div>

                <div class="drill-card type-theory">
                    <div class="drill-q">
                        <span>Q3. B-tree と NULL</span>
                        <span class="star-rating">★★☆☆☆</span>
                    </div>
                    <div>
                        <p>「B-tree インデックスには NULL 値が含まれないため、<code>IS NULL</code> 検索は常に全表走査になる」という説は正しいですか？（PostgreSQLの場合）
                        </p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 間違い (False)</strong><br>
                            Oracle
                            DBなど一部のDBMSではNULLがインデックスに含まれない場合がありますが、<strong>PostgreSQLのB-treeはNULLをインデックスに含みます</strong>（デフォルトではソート順の最後尾）。<br>
                            したがって、<code>WHERE col IS NULL</code> に対しても Index Scan は有効です。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-theory">
                    <div class="drill-q">
                        <span>Q4. 選択率 (Selectivity) の閾値</span>
                        <span class="star-rating">★★☆☆☆</span>
                    </div>
                    <div>
                        <p>「インデックスを作ったのに、オプティマイザが頑なに Seq Scan を選ぶ」という現象がよく起きます。<br>
                            一般的に、全体の何%程度のヒット率を超えると、オプティマイザはインデックススキャンより Seq Scan (または Bitmap Scan) の方が速いと判断しますか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 5% 〜 15% 程度</strong><br>
                            「20%程度」と言われることもありますが、近年のSSD環境においてもランダムアクセスはシーケンシャルアクセスよりコストが高く、数%〜10%程度のヒット率を超えると、オプティマイザは
                            Seq Scan や Bitmap Scan に切り替える傾向があります。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-theory">
                    <div class="drill-q">
                        <span>Q5. クラスター化係数</span>
                        <span class="star-rating">★★★☆☆</span>
                    </div>
                    <div>
                        <p><code>CLUSTERING_FACTOR</code> (物理的な並び順とインデックス順の相関) が悪い（0に近い）場合、Index Scan が遅くなる理由は？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: ランダムアクセスが多発するため。</strong><br>
                            インデックス上で隣り合っているID (例: 100, 101, 102)
                            が、Heap（テーブル本体）上では全く別のページに散らばっている場合、それぞれ別々のページを読み込む必要があり、ディスクI/Oが激増します。
                        </div>
                    </details>
                </div>
            </div>

            <h3>第2部: SQLコーディングドリル (Writing Query & DDL)</h3>
            <p><strong>課題:</strong> 以下の要件を満たすSQL（主に <code>CREATE INDEX</code> 文）を記述してください。</p>

            <div class="drill-container">

                <div class="drill-card type-sql">
                    <div class="drill-q">
                        <span>Q6. 名前検索の高速化</span>
                        <span class="star-rating">★☆☆☆☆</span>
                    </div>
                    <div>
                        <p><code>SELECT * FROM users WHERE email = ?</code> の実行計画を確認すると、<strong>Seq Scan (全表走査)</strong>
                            が選択されていました。<br>
                            このクエリを <strong>Index Scan</strong> に変更させるためのチューニングを行ってください。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <pre><code class="language-sql">CREATE INDEX idx_users_email ON users(email);</code></pre>
                            <p><strong>解説:</strong>
                                オプティマイザに「インデックスを使う」という選択肢を与える必要があります。カーディナリティが高い（重複が少ない）カラムであれば、オプティマイザは即座に Index Scan
                                に切り替えます。</p>
                        </div>
                    </details>
                </div>

                <div class="drill-card type-sql">
                    <div class="drill-q">
                        <span>Q7. 年別データの抽出 (関数インデックス)</span>
                        <span class="star-rating">★★☆☆☆</span>
                    </div>
                    <div>
                        <p><code>WHERE extract(year from created_at) = 2025</code> という条件に対し、インデックスを作成したにもかかわらず
                            <strong>Seq Scan</strong> のままでした。<br>
                            なぜオプティマイザはインデックスを使えないのですか？また、どうすれば使えるようになりますか？
                        </p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: カラムが関数で加工されているから。</strong><br>
                            B-treeには「生の created_at」順でデータが入っていますが、オプティマイザは「年だけ取り出した値」の順序を知りません。<br>
                            解決策: <br>
                            <pre><code class="language-sql">CREATE INDEX idx_users_year ON users( extract(year from created_at) );</code></pre>
                            関数インデックスを作成することで、計算済みの値に対するパスをオプティマイザに提供できます。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-sql">
                    <div class="drill-q">
                        <span>Q8. 複合条件とソート</span>
                        <span class="star-rating">★★★☆☆</span>
                    </div>
                    <div>
                        <p>記事一覧クエリの実行計画に <strong>Sort Key: created_at DESC</strong> というノードが出現し、メモリを消費しています。<br>
                            この <strong>Sort ノードを消滅させる</strong>（オプティマイザにソート不要と判断させる）ためのインデックス戦略は？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <pre><code class="language-sql">CREATE INDEX idx_posts_cat_date ON posts(category_id, created_at DESC);</code></pre>
                            <p><strong>解説:</strong> オプティマイザは「インデックスが既にソートされている」ことを知っています。
                                <code>category_id</code> で絞り込んだ後、<code>created_at</code>
                                順に並んでいるB-treeがあれば、そのまま読み出すだけでよいため、Sort処理をスキップできます。
                            </p>
                        </div>
                    </details>
                </div>

                <div class="drill-card type-sql">
                    <div class="drill-q">
                        <span>Q9. 部分インデックス (Partial Index)</span>
                        <span class="star-rating">★★★☆☆</span>
                    </div>
                    <div>
                        <p>退職済みフラグを含むテーブルで、ごく一部の「在職中」データだけを検索します。<br>
                            しかし、通常のインデックスでは無駄な「退職済みデータ」まで管理され、更新コストとディスク容量を圧迫しています。<br>
                            <strong>オプティマイザに「在職中の行だけ」のパスを提供しつつ、サイズを最小化する</strong> 手法は？
                        </p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <pre><code class="language-sql">CREATE INDEX idx_active ON employees(id) WHERE deleted_at IS NULL;</code></pre>
                            <p><strong>解説:</strong> 部分インデックス (Partial Index) です。オプティマイザはクエリの <code>WHERE</code>
                                句を見て「このインデックスを使えば無駄なスキャンをしなくて済む」と判断し、利用します。</p>
                        </div>
                    </details>
                </div>

                <div class="drill-card type-sql">
                    <div class="drill-q">
                        <span>Q10. カバリングインデックス</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p>実行計画を見ると <strong>Heap Fetches</strong> が発生しており、テーブル本体へのアクセスがボトルネックになっています。<br>
                            これを <strong>Heap Fetches: 0 (Index Only Scan)</strong> に変えるためのチューニングを行ってください。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <pre><code class="language-sql">CREATE INDEX idx_cover ON products(category_id) INCLUDE (id, price);</code></pre>
                            <p><strong>解説:</strong>
                                カバリングインデックスです。クエリに必要な全てのカラムをインデックス（KeyまたはInclude）に含めることで、オプティマイザは「テーブルを見に行く必要がない」と判断し、高速なパスを選択します。
                            </p>
                        </div>
                    </details>
                </div>
            </div>

            <h3>第3部: トラブルシューティング・上級 (Advanced Scenario)</h3>

            <div class="drill-container">
                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q11. 複合インデックスの順序</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p>以下のクエリに対し、<code>(A, B)</code> という複合インデックスが存在します。</p>
                        <pre class="drill-code"><code class="language-sql">SELECT * FROM tbl WHERE B = 2;</code></pre>
                        <p>しかし、実行計画を見ると <strong>Seq Scan</strong>
                            が選ばれています（インデックスが使われません）。なぜオプティマイザはこのインデックスを採用しなかったのですか？<br>
                            条件: <code>A</code> は性別（カーディナリティ低）、<code>B</code> は会員ランク（カーディナリティ中）。<br>
                            単体での検索頻度は <code>B</code> の方が多い。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 最左プレフィックス (Leftmost Prefix) の制約。</strong><br>
                            B-tree は、インデックス定義の「左側のカラム」から順にソートされています。<code>(A, B)</code>
                            の場合、Aが決まって初めてBが並ぶため、Aを指定せずにBだけで探索することは（全索引走査以外）不可能です。オプティマイザは「これなら全表走査(Seq
                            Scan)の方がマシ」と判断しました。<br>
                            解決策: <code>(B, A)</code> または <code>(B)</code> のインデックスを作成すること。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q12. LIKE検索と実行計画</span>
                        <span class="star-rating">★★★☆☆</span>
                    </div>
                    <div>
                        <p><code>WHERE address LIKE '%東京都%'</code> の実行計画が <strong>Seq Scan</strong> になりました。<br>
                            B-treeインデックスが存在するのに、なぜオプティマイザはそれを使わなかった（使えなかった）のですか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 中間一致はB-treeの探索ロジックと合致しないため。</strong><br>
                            B-treeは「辞書順」でソートされています。先頭文字が不明な <code>%東京都%</code>
                            は、辞書のどこを見ればいいか特定できないため、オプティマイザは「全ページ読むしかない」と判断しました。<br>
                            解決策: <code>pg_trgm</code> (GIN Index) を導入することで、オプティマイザに新たなパスを提供できます。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q13. Offset のコスト要因</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p><code>LIMIT 50 OFFSET 1000000</code> の実行計画を見ると、コストが非常に高く、実行時間も長いです。<br>
                            オプティマイザは効率的に「100万行スキップ」できないのでしょうか？その理由を構造的に説明してください。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 行の可視性などを行ごとにチェックする必要があるため。</strong><br>
                            RDBの構造上、「100万番目」という位置情報は事前に維持されていません（行削除やMVCCがあるため）。<br>
                            そのため、オプティマイザは「先頭から100万行を読み込み、可視性を確認して、捨てる」という処理を計画せざるを得ません。これが高コストの理由です。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q14. Plan Rows と Actual Rows の乖離</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p>実行計画で、<code>rows=1</code> (推定) となっているのに、<code>Actual rows=10000</code> (実測) と大きな乖離がありました。<br>
                            これが原因で Nested Loop が選ばれてしまい、激遅になっています。原因と解決策は？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 統計情報の欠損（Stale Statistics）。解決策は ANALYZE。</strong><br>
                            オプティマイザは統計情報（pg_statistic）を元にコスト計算をします。データが大量に更新されたのに統計情報が古いと、オプティマイザは「1行しかないならNested
                            Loopが最速だ」と判断を誤ります。<br>
                            <code>ANALYZE table_name;</code> を実行して統計情報を最新化することで、正しい計画（Hash Joinなど）が選ばれるようになります。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q15. 結合アルゴリズムの選択 (Join Strategy)</span>
                        <span class="star-rating">★★★☆☆</span>
                    </div>
                    <div>
                        <p>テーブルA (10行) と テーブルB (100万行) を結合する際、オプティマイザは <strong>Nested Loop Join</strong> と <strong>Hash
                                Join</strong> のどちらを選ぶ可能性が高いですか？<br>
                            また、その判断基準（コスト構造）を説明してください。</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: Nested Loop Join。</strong><br>
                            Nested Loopは「Aの1行ごとにBを検索する」方式です。<br>
                            Aが極端に小さい場合、Bにインデックスがあれば「10回インデックスを引く」だけで済み、非常に高速です。<br>
                            逆にAもBも大きい場合、オプティマイザは事前にハッシュテーブルを作る Hash Join や、ソートして結合する Merge Join を選択します。
                        </div>
                    </details>
                </div>
            </div>

            <!-- Q16-Q20: Expert Maniac Challenge -->
            <h3>おまけ: 超上級・マニアック自由研究 (Q16-Q20)</h3>
            <div class="drill-container">

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q16. Index Only Scan と Heap Fetches</span>
                        <span class="star-rating">★★★★★</span>
                    </div>
                    <div>
                        <p><code>EXPLAIN ANALYZE</code> の結果、<strong>Index Only Scan</strong> が選ばれているのに、<strong>Heap
                                Fetches: 5000</strong> と表示され、期待したほど速くありません。<br>
                            この数字は何を意味し、なぜ発生しているのですか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: インデックスだけでは可視性を判断できなかった（Visibility Mapの更新遅れ）。</strong><br>
                            PostgreSQLのMVCCでは、インデックス上のタプルが「有効（コミット済み）」かどうかを確認する必要があります。<br>
                            通常は <strong>Visibility Map</strong>
                            を見て判断しますが、更新直後などでマップが古いままだと、結局テーブル本体（Heap）を見に行く必要があります。これが Heap Fetches です。<br>
                            解決策: <code>VACUUM tables;</code>
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q17. BitmapOr の仕組み</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p><code>WHERE A=1 OR B=2</code> の時、オプティマイザは2つのインデックスをどう組み合わせますか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 各インデックスの結果（TID）をビットマップ化してOR演算する。</strong><br>
                            1. インデックスAからヒットしたTIDリストをビットマップ（0/1）にする。<br>
                            2. インデックスBも同様にビットマップにする。<br>
                            3. 両者のビットごとの論理和 (OR) をとる。<br>
                            4. 結果が1になったページ/行だけをHeapに取りに行く。<br>
                            これが <code>BitmapOr</code> ノードの仕事です。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q18. BRIN と Lossy Bitmap Scan</span>
                        <span class="star-rating">★★★★☆</span>
                    </div>
                    <div>
                        <p>BRINインデックスを使った実行計画に <strong>Bitmap Heap Scan (Lossy)</strong> と表示されました。<br>
                            通常のB-treeのBitmap Scanと異なり、「Lossy（不正確）」とはどういう意味ですか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 厳密なTIDではなく、ブロック単位で「あるかも」と判定しているから。</strong><br>
                            BRINはページ（ブロック）のレンジ（最小値・最大値）しか持っていません。「このページに含まれる可能性がある」という粒度でビットマップを作るため、実際にページを開いてみないとマッチするか確定しません（Recheckが必要）。これが
                            Lossy の意味です。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q19. VACUUM FULL と実行計画の変化</span>
                        <span class="star-rating">★★★★★</span>
                    </div>
                    <div>
                        <p><code>VACUUM FULL</code> (または CLUSTER) を実行した後、それまで <strong>Bitmap Scan</strong> だったクエリが
                            <strong>Index Scan</strong> に変わり、劇的に高速化しました。<br>
                            オプティマイザの判断を変えさせた「物理的な統計情報の変化」は何ですか？
                        </p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: 相関度 (Correlation/Clustering Factor) の向上。</strong><br>
                            テーブルが再構築されたことで、物理的な行の並び順とインデックスの順序が一致（相関度が高く）なりました。<br>
                            オプティマイザは「ランダムアクセスが減り、シーケンシャルに近い速度でディスクを読める」と判断し、コスト見積もりを大幅に下げたため、Index Scan が選ばれるようになりました。
                        </div>
                    </details>
                </div>

                <div class="drill-card type-hard">
                    <div class="drill-q">
                        <span>Q20. Planning Time の増大</span>
                        <span class="star-rating">★★★★★</span>
                    </div>
                    <div>
                        <p>あるクエリの実行時間は 1ms なのに、<strong>Planning Time = 100ms</strong> となっています。<br>
                            オプティマイザが「考え」すぎてしまっている原因として、インデックス構成の観点から何が考えられますか？</p>
                    </div>
                    <details>
                        <summary>解答を表示</summary>
                        <div class="answer">
                            <strong>解答: インデックスの過剰作成（選択肢が多すぎる）。</strong><br>
                            オプティマイザ（GEQO等）は、可能なアクセスパスの組み合わせを探索してコスト最小のプランを探します。
                            無駄なインデックスが大量にあると、それら全てを「使うべきか否か」の検討対象に含めてしまうため、計算量爆発（Combinatorial
                            Explosion）を起こし、計画作成時間が実行時間を上回る現象が発生します。
                        </div>
                    </details>
                </div>
            </div>
        </section>
        </section>
        <footer style="margin-top: 80px; padding: 40px; background-color: #2c3e50; color: white; text-align: center;">
            <p>
                本コンテンツの作成時間：約15時間
            </p>
        </footer>

    </main>
</body>

</html>